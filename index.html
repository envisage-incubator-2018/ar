<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
			/* Position the button on the bottom of the page. */
			#ui {
			  position: absolute;
			  bottom: 10px;
			  left: 50%;
			  transform: translate(-50%, -50%);
			  text-align: center;
			  font-family: 'Karla', sans-serif;
			  z-index: 1;
			}

			a#magic-window {
			  display: block;
			  color: white;
			  margin-top: 1em;
}
		</style>
	</head>
	<body>
	  <div id="ui">
		<div id="vr-button"></div>
			<a id="magic-window" href="#">Try it without a headset</a>
		</div>
		<script src="js/three.js"></script>
		<script src ="js/OBJLoader.js"></script>
		<script src="node_modules/three/src/math/Vector3.js" ></script>
		<script src ="js/GLTFLoader.js"></script>
		<script src="node_modules/three/examples/js/effects/VREffect.js"></script>

		
		<script src="node_modules/three/examples/js/controls/VRControls.js"></script>
		<!--
		  A polyfill for WebVR using the Device{Motion,Orientation}Event API.
		-->
		<script src="node_modules/webvr-polyfill/build/webvr-polyfill.min.js"></script>

		<!--
		  A set of UI controls for entering VR mode.
		-->
		<script src="node_modules/webvr-ui/build/webvr-ui.min.js"></script>
		<!--
		  A set of UI controls for entering VR mode.
		-->
		<script src="node_modules/webvr-ui/build/webvr-ui.min.js"></script>		
		
		<script>
		
					
			var renderer = new THREE.WebGLRenderer
			renderer.setSize(window.innerWidth, window.innerHeight)
			document.body.appendChild (renderer.domElement)
			var scene = new THREE.Scene()
			// Model loader then texture loader
			
			var gLoader = new THREE.GLTFLoader();
			var textureLoader = new THREE.TextureLoader();

			
			
			var groundTex = textureLoader.load('tex/ground.jpg')
			var groundMat = new THREE.MeshStandardMaterial({map: groundTex})
			
			var cubeTex = textureLoader.load('tex/box.jpg')
			var cubeMat = new THREE.MeshStandardMaterial({map: cubeTex})			
			
			var cloudTex = textureLoader.load('tex/cloud.jpg')
			var cloudMat = new THREE.MeshToonMaterial({map: cloudTex})
			
			var loader = new THREE.OBJLoader();
			var white = new THREE.MeshBasicMaterial( { color: 0x707070  } )
			// load a resource
			loader.load(

				'mod/untitled.obj',
				// called when resource is loaded
				function ( ground ) {
					
					groundRef = ground
					ground.traverse(function(node){
						if (node.isMesh) node.material = groundMat
					
					})
					
					scene.add( ground );

				}
			);
			
			var cloudRef = []
			var trackCloudLocation =[]
			
			//using a while loop because for loop would iterate through everything except what was underneath gLoader and then do that last with i held at 16
			var y = 0
			for(i=0; i<32; i++){
				//console.log("check 0 i is " + i)
				gLoader.load("mod/cloud.gltf", function(gltf){
					gltf.scene.traverse( function ( node ) {
					//console.log("check 1 i is " + i)
						if ( node.isMesh ) {
							//console.log("check 2 i is " + i)
							
							node.material = cloudMat;
							node.position.y = 8
							node.position.z = Math.random() * 100 - 50
							var xVal = Math.random() * 100 - 50
							node.position.x = xVal
							trackCloudLocation[y] =xVal
							node.rotation.y= Math.PI/2
							//console.log("check 3 i is " + i)
							cloudRef[y]=gltf.scene
							//console.log("cloud " + y + " logged")
							//console.log(cloudRef[y])
							scene.add(gltf.scene)
							y++
						}

					} );	
					//console.log("check 4 i is " + i)
					


					
					})
				//console.log("check 5 i is " + i)
			}
			//cloud.position.y = 10		
			//var ambLight = new THREE.AmbientLight( 0x101010 ); // soft white light
			//scene.add( ambLight );
			
		

			
			var geometry = new THREE.BoxGeometry( 1, 1, 1 )
			//var material = new THREE.MeshBasicMaterial( { color: 0xff0000 })					
			var cube = new THREE.Mesh( geometry, cubeMat )
			scene.add( cube )
			
			
			
			skyTex = textureLoader.load("tex/sky.jpg")
			var skyMat = new THREE.MeshBasicMaterial({
					map: skyTex,
					side: THREE.BackSide
			});
			
			var skyGeo = new THREE.BoxGeometry (50, 50, 50)			
			var skyCube = new THREE.Mesh( skyGeo, skyMat)
			skyCube.position.y=5
			scene.add( skyCube )			
			
			
			var directionalLight = new THREE.DirectionalLight( 0xffffff, 1);
			lightPos =   new THREE.Vector3(2,10,5)
			directionalLight.position.copy( lightPos)
			scene.add( directionalLight );
			//directionalLight.target = cube

			var vrButton;
			
			var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );			
			camera.position.z = 5;
			camera.position.y = 3;
			//camera.position = new THREE.Vector3(0,10,0)
		
			 controls = new THREE.VRControls(camera);
			 controls.standing = true;
			 camera.position.y = controls.userHeight;
			 // Apply VR stereo rendering to renderer.
			 effect = new THREE.VREffect(renderer);
			 effect.setSize(window.innerWidth, window.innerHeight);
				
		
			 var uiOptions = {
				color: 'black',
				background: 'white',
				corners: 'square'
			 };
			  window.addEventListener('resize', onResize, true);
			  window.addEventListener('vrdisplaypresentchange', onResize, true);

			  // Initialize the WebVR UI.
			  var uiOptions = {
				color: 'black',
				background: 'white',
				corners: 'square'
			  };
			  vrButton = new webvrui.EnterVRButton(renderer.domElement, uiOptions);
			  vrButton.on('exit', function() {
				camera.quaternion.set(0, 0, 0, 1);
				camera.position.set(0, controls.userHeight, 0);
			  });
			  vrButton.on('hide', function() {
				document.getElementById('ui').style.display = 'none';
			  });
			  vrButton.on('show', function() {
				document.getElementById('ui').style.display = 'inherit';
			  });
			  document.getElementById('vr-button').appendChild(vrButton.domElement);
			  document.getElementById('magic-window').addEventListener('click', function() {
				vrButton.requestEnterFullscreen();
			  });

			function onResize(e) {
				  effect.setSize(window.innerWidth, window.innerHeight);
				  camera.aspect = window.innerWidth / window.innerHeight;
				  camera.updateProjectionMatrix();
			}
			//SOURCE https://stackoverflow.com/questions/28121820/how-to-write-a-getworldposition-function-in-three-js
			function getObjPos(obj){
				obj.updateMatrixWorld();
				var vec= new THREE.Vector3();
				vec.setFromMatrixPosition(obj.matrixWorld);
				return {vec: 'x'}; // Like this?
			}
			
			
			var cloudMoveSpeed = 0.01
			function animate() {
				
			
				requestAnimationFrame( animate);
				renderer.render(scene, camera);
				effect.render(scene, camera);
				
				//skyCube.rotation.y +=0.001
				  // Only update controls if we're presenting.
				  if (vrButton.isPresenting()) {
					controls.update();
				  }
				
				cube.position.y +=0.01
				cube.position.x -= 0.01
				cube.rotation.x += 0.01
				cube.rotation.y += 0.1
				var j = 0
				while(j<32){
					//console.log("moving " + j)
					
					if (trackCloudLocation[j] < -50){ //Doesn't seem to be world position, local to something but I dont know what
					
						cloudRef[j].position.x = 50
						trackCloudLocation[j] = 50
						console.log("success" + j)
					}
					//console.log(getObjPos(cloudRef[j]))
					
					cloudRef[j].position.x -= cloudMoveSpeed
					trackCloudLocation[j] -= cloudMoveSpeed
					j+=1
				}
				//groundRef.position.x += 0.01
			}
			animate()
		</script>
		
		
		
	</body>
</html>